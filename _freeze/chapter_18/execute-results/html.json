{
  "hash": "5ad6522b13ed1ec2a1a913ee3284b6f4",
  "result": {
    "markdown": "---\ntitle: \"Visualization and interpretation of individualized treatment rule results\"\nauthors:   \n  - name: Xiaotong Jiang\n    orcid: 0000-0003-3698-4526\n    affiliations:\n      - ref: biogen\naffiliations:\n  - id: smartdas\n    name: Smart Data Analysis and Statistics B.V.\n    city: Utrecht\n  - id: biogen\n    name: Biogen\n    city: Cambridge, MA, US\nformat:\n  html:\n    toc: true\n    number-sections: true\nexecute:\n  cache: true\nbibliography: 'https://api.citedrive.com/bib/0d25b38b-db8f-43c4-b934-f4e2f3bd655a/references.bib?x=eyJpZCI6ICIwZDI1YjM4Yi1kYjhmLTQzYzQtYjkzNC1mNGUyZjNiZDY1NWEiLCAidXNlciI6ICIyNTA2IiwgInNpZ25hdHVyZSI6ICI0MGFkYjZhMzYyYWE5Y2U0MjQ2NWE2ZTQzNjlhMWY3NTk5MzhhNzUxZDNjYWIxNDlmYjM4NDgwOTYzMzY5YzFlIn0=/bibliography.bib'\n---\n\n\n\n\nIn this tutorial, we will walk you through the code that implemented the precision medicine methods and generated the visualization results discussed in Chapter 18 of the book. This tutorial focuses more on helping you understand the code. We will not provide detailed interpretation of the results as they have been covered in the chapter already. \n\n## Introduction\n\nWe first load all relevant functions for this chapter.\n\n\n::: {.cell hash='chapter_18_cache/html/constant_814e65a8dc678add3882d8c49a984b05'}\n\n```{.r .cell-code}\nsource(\"resources/chapter 18/functions.r\")\n```\n:::\n\n\nSubsequently, we use the function `simcountdata()` to generate an example dataset with a sample size of N=2000. In this example, we have two disease modifying therapies (DMT1 and DMT0) and the outcome is the number of post-treatment multiple sclerosis relapses during follow-up. \n                    \n\n::: {.cell hash='chapter_18_cache/html/readdata_c5b04be0ad594652d08965f9942d2153'}\n\n```{.r .cell-code}\n# Randomization seed\nbase.seed <- 999\n\nset.seed(base.seed)\ndf.ori <- simcountdata(n = 2000,\n                       seed = 63,\n                       beta = c(log(0.4), log(0.5), log(1), log(1.1), log(1.2)),\n                       beta.x = c(-1.54, -0.01, 0.06, 0.25, 0.5, 0.13, 0.0000003)\n)$data\n```\n:::\n\n\nThe dataset looks as follows:\n\n\n::: {.cell hash='chapter_18_cache/html/unnamed-chunk-1_9375bdfdc1572c72190f08de327b2cf4'}\n\n```{.r .cell-code}\nhead(df.ori)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  trt ageatindex_centered female prerelapse_num prevDMTefficacy premedicalcost\n1   0                   2      0              2    Low efficacy        4606.04\n2   1                  10      1              1    Low efficacy       17065.19\n3   1                  12      1              2            None        6308.39\n4   1                 -12      0              0    Low efficacy       16633.97\n5   1                  13      1              0    Low efficacy         642.96\n6   1                  14      1              0    Low efficacy        2989.89\n  numSymptoms postrelapse_num finalpostdayscount     group     score Iscore\n1           0               1                305 Simulated 0.7129792      1\n2           1               0                367 Simulated 0.7404238      2\n3           0               0                325 Simulated 0.7564233      3\n4           0               0                321 Simulated 0.7215764      1\n5           0               0                 24 Simulated 0.7457823      2\n6           0               0                 59 Simulated 0.7441632      2\n```\n:::\n:::\n\n\nBelow is a summary table of the baseline characteristics by treatment group. \n\n\n::: {.cell hash='chapter_18_cache/html/unnamed-chunk-2_da2393e476ad977941fa33b4366a6c55'}\n::: {.cell-output-display}\n```{=html}\n<div class=\"Rtable1\"><table class=\"Rtable1\"><caption>Baseline characteristics of the case study data</caption>\n\n<thead>\n<tr>\n<th class='rowlabel firstrow lastrow'></th>\n<th class='firstrow lastrow'><span class='stratlabel'>0<br><span class='stratn'>(N=506)</span></span></th>\n<th class='firstrow lastrow'><span class='stratlabel'>1<br><span class='stratn'>(N=1494)</span></span></th>\n<th class='firstrow lastrow'><span class='stratlabel'>Overall<br><span class='stratn'>(N=2000)</span></span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class='rowlabel firstrow'>Age (years)</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>Mean (SD)</td>\n<td>45.2 (9.82)</td>\n<td>45.8 (9.73)</td>\n<td>45.7 (9.75)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>Median [Min, Max]</td>\n<td class='lastrow'>46.0 [20.0, 64.0]</td>\n<td class='lastrow'>46.0 [19.0, 64.0]</td>\n<td class='lastrow'>46.0 [19.0, 64.0]</td>\n</tr>\n<tr>\n<td class='rowlabel firstrow'>Gender</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>female</td>\n<td>375 (74.1%)</td>\n<td>1123 (75.2%)</td>\n<td>1498 (74.9%)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>male</td>\n<td class='lastrow'>131 (25.9%)</td>\n<td class='lastrow'>371 (24.8%)</td>\n<td class='lastrow'>502 (25.1%)</td>\n</tr>\n<tr>\n<td class='rowlabel firstrow'>Previous number of relapses</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>0</td>\n<td>319 (63.0%)</td>\n<td>973 (65.1%)</td>\n<td>1292 (64.6%)</td>\n</tr>\n<tr>\n<td class='rowlabel'>1</td>\n<td>150 (29.6%)</td>\n<td>427 (28.6%)</td>\n<td>577 (28.9%)</td>\n</tr>\n<tr>\n<td class='rowlabel'>2</td>\n<td>31 (6.1%)</td>\n<td>76 (5.1%)</td>\n<td>107 (5.4%)</td>\n</tr>\n<tr>\n<td class='rowlabel'>3</td>\n<td>5 (1.0%)</td>\n<td>17 (1.1%)</td>\n<td>22 (1.1%)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>4</td>\n<td class='lastrow'>1 (0.2%)</td>\n<td class='lastrow'>1 (0.1%)</td>\n<td class='lastrow'>2 (0.1%)</td>\n</tr>\n<tr>\n<td class='rowlabel firstrow'>Efficacy of previous disease modifying therapy</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>Low efficacy</td>\n<td>216 (42.7%)</td>\n<td>609 (40.8%)</td>\n<td>825 (41.3%)</td>\n</tr>\n<tr>\n<td class='rowlabel'>Medium and high efficacy</td>\n<td>53 (10.5%)</td>\n<td>179 (12.0%)</td>\n<td>232 (11.6%)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>None</td>\n<td class='lastrow'>237 (46.8%)</td>\n<td class='lastrow'>706 (47.3%)</td>\n<td class='lastrow'>943 (47.2%)</td>\n</tr>\n<tr>\n<td class='rowlabel firstrow'>Previous medical cost (\\$)</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>Mean (SD)</td>\n<td>13700 (20400)</td>\n<td>14400 (24500)</td>\n<td>14300 (23600)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>Median [Min, Max]</td>\n<td class='lastrow'>7320 [343, 264000]</td>\n<td class='lastrow'>7560 [110, 556000]</td>\n<td class='lastrow'>7470 [110, 556000]</td>\n</tr>\n<tr>\n<td class='rowlabel firstrow'>Previous number of symptoms</td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n<td class='firstrow'></td>\n</tr>\n<tr>\n<td class='rowlabel'>0</td>\n<td>348 (68.8%)</td>\n<td>995 (66.6%)</td>\n<td>1343 (67.2%)</td>\n</tr>\n<tr>\n<td class='rowlabel'>1</td>\n<td>119 (23.5%)</td>\n<td>388 (26.0%)</td>\n<td>507 (25.4%)</td>\n</tr>\n<tr>\n<td class='rowlabel lastrow'>>=2</td>\n<td class='lastrow'>39 (7.7%)</td>\n<td class='lastrow'>111 (7.4%)</td>\n<td class='lastrow'>150 (7.5%)</td>\n</tr>\n</tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe now define key constants for the case study.\n\n\n::: {.cell hash='chapter_18_cache/html/unnamed-chunk-3_0de260770889324144e9385d94dee021'}\n\n```{.r .cell-code}\n# Baseline characteristics\ncovars <- c(\"age.z\", \"female\", \"prevtrtB\", \"prevtrtC\", \"prevnumsymp1\", \n            \"prevnumsymp2p\", \"previous_cost.z\", \"previous_number_relapses\")\n\n# Precision medicine methods to be used\npm.methods <- c(\"all1\", \"all0\", \"poisson\", \"dWOLS\", \"listDTR2\", \n                \"contrastReg\")\n\n# Precision medicine method labels\nmethod.vec <- c(\"All 0\", \"All 1\", \"Poisson\", \"dWOLS\", \n                \"Contrast\\n Regression\", \"List DTR\\n (2 branches)\")\n\n# Number of folds in each CV iteration\nn.fold <- 5\n\n# Number of CV iterations\nn.cv <- 10\n\n# Sample size of the large independent test set to get true value\nbig.n <- 100000\n\n# Define formula for the CATE model\ncate.formula <- as.formula(paste0(\"y ~\", paste0(covars, collapse = \"+\"), \n                                  \"+ offset(log(years))\"))\n\n# Define formula for the propensity score model\nps.formula <- trt ~ age.z + prevtrtB + prevtrtC\n\n# Color\nmyblue <- rgb(37, 15, 186, maxColorValue = 255)\nmygreen <- rgb(109, 173, 70, maxColorValue = 255)\nmygrey <- rgb(124, 135, 142, maxColorValue = 255)\n```\n:::\n\n\nThe data need to be preprocessed to be more analyzable. We recategorized treatment, previous treatment, and number of symptoms; scaled medical cost and age; and standardized the data. \n\n::: {.cell hash='chapter_18_cache/html/preprocess_8a45bc84b008e97982327da28f5891b2'}\n\n```{.r .cell-code}\ndf <- df.ori %>%\n  rename(previous_treatment = prevDMTefficacy,\n         age = ageatindex_centered,\n         y = postrelapse_num,\n         previous_number_relapses = prerelapse_num,\n         previous_number_symptoms = numSymptoms,\n         previous_cost = premedicalcost) %>%\n  mutate(previous_treatment = factor(previous_treatment, \n                                     levels = c(\"None\", \"Low efficacy\", \"Medium and high efficacy\"), \n                                     labels = c(\"drugA\", \"drugB\", \"drugC\")),\n         previous_number_symptoms = factor(previous_number_symptoms, \n                                           levels = c(\"0\", \"1\", \">=2\"), \n                                           labels = c(\"0\", \"1\", \">=2\")),\n         trt = factor(trt, levels = c(0, 1), labels = c(\"drug0\", \"drug1\")),\n         previous_cost.z = scale(log(previous_cost), scale = TRUE), # log-transformed due to skewness\n         age.z = age + 48,\n         age.z = scale(age.z, scale = TRUE),\n         years = finalpostdayscount / 365.25,\n         mlogarr0001 = -log(y / years + 0.001),\n         drug1 = as.numeric(trt == \"drug1\"),\n         prevtrtB = as.numeric(previous_treatment == \"drugB\"),\n         prevtrtC = as.numeric(previous_treatment == \"drugC\"),\n         prevnumsymp1 = as.numeric(previous_number_symptoms == \"1\"),\n         prevnumsymp2p = as.numeric(previous_number_symptoms == \">=2\")) %>%\n  dplyr::select(age.z, female, contains(\"prevtrt\"), previous_cost.z, contains(\"prevnumsymp\"), \n                previous_number_relapses, trt, drug1, y, mlogarr0001, years, Iscore)\n\n# Standardize data\ndf.s <- df\ndf.s[, setdiff(covars, c(\"age.z\", \"previous_cost.z\"))] <- df[, setdiff(covars, c(\"age.z\", \"previous_cost.z\"))]\n```\n:::\n\n\n## Estmition of individualized treatment rules\n\nThe following code provides details of how to implement the precision medicine methods in the example data. Please feel free to jump to the next section if you want to focus on the results. The model results are available online for you to load and save time. \n\nWe used the function `listdtr()` in the **listdtr** package to estimate individualized treatment rules (ITRs) based on the listDTR method. We used the function `catefit()` in the **precmed** package to estimate ITRs based on the Poisson and contrast regression method. These were the methods used in Section 3 of the book where we talked about directly visualizing the ITR before bringing in the outcomes. The methods are discussed in further detail by @zhao_effectively_2013 and @yadlowsky_estimation_2021.\n\n\n::: {.cell hash='chapter_18_cache/html/apply.s3_720264bb9bdd915423a3aaf5052d04c4'}\n\n```{.r .cell-code}\nlibrary(listdtr)\n\n# Estimated ITR based on the listDTR method with 2 branches\nmodlist2 <- listdtr(y = df$mlogarr, # larger is more favorable\n                   a = df$drug1,\n                   x = df[, c(\"age.z\", \"female\", \"prevtrtB\", \"prevtrtC\", \"previous_cost.z\",\n                              \"prevnumsymp1\", \"prevnumsymp2p\", \"previous_number_relapses\")],\n                   stage.x = rep(1, 8), maxlen = 2L) # somewhat slow\n\n# Estimated ITR based on the listDTR method with 3 branches\nmodlist3 <- listdtr(y = df$mlogarr,\n                    a = df$drug1,\n                    x = df[, c(\"age.z\", \"female\", \"prevtrtB\", \"prevtrtC\", \"previous_cost.z\",\n                               \"prevnumsymp1\", \"prevnumsymp2p\", \"previous_number_relapses\")],\n                    stage.x = rep(1, 8), maxlen = 3L) # somewhat slow\n\n# Estimated CATE score based on the Poisson and contrast regression \nmodpm <- catefit(response = \"count\",\n            cate.model = cate.formula,\n            ps.model = ps.formula,\n            data = df,\n            higher.y = FALSE,\n            score.method = c(\"poisson\", \"contrastReg\"),\n            initial.predictor.method = \"poisson\",\n            seed = 999)\n\n# Estimated CATE score based on the Poisson and contrast regression \n# (based on the scaled data so the coefficients are easier to compare)\nmodpm.s <- catefit(response = \"count\",\n              cate.model = cate.formula,\n              ps.model = ps.formula,\n              data = df.s,\n              higher.y = FALSE,\n              score.method = c(\"poisson\", \"contrastReg\"),\n              initial.predictor.method = \"poisson\",\n              seed = 999)\n```\n:::\n\n\nFor results in Sections 4 and 5, we applied cross validation to mitigate  over-fitting. For this chapter, we created our own customized function `cvvalue()` to estimate the ITR and calculate the estimated value function via cross validation for all methods, including the fixed method. The results were all saved under the prefix `cvmod`. The **precmed** package has a built-in cross validation procedure for CATE estimation so we used the function `catefit()`.\n\n\n::: {.cell hash='chapter_18_cache/html/apply.s4s5_e1b78ab73915378ab89757ed61fbdd0f'}\n\n```{.r .cell-code}\n# Run cross validation for each method (used for Sections 4 & 5)\n  \n## Estimated CATE scores based on the Poisson and contrast regression with cross-validation\nmodcv <- catecv(response = \"count\",\n                cate.model = cate.formula,\n                ps.model = ps.formula,\n                data = df,\n                higher.y = FALSE,\n                score.method = c(\"poisson\", \"contrastReg\"),\n                initial.predictor.method = \"poisson\",\n                cv.n = n.cv,\n                plot.gbmperf = FALSE,\n                seed = 999) # somewhat slow\n\n## Estimated value function for each method\ncvmodall0 <- cvvalue(data = df, xvar = covars,\n                     method = \"all0\", n.fold = n.fold, n.cv = n.cv, \n                     seed = base.seed)\n\ncvmodall1 <- cvvalue(data = df, xvar = covars,\n                     method = \"all1\", n.fold = n.fold, n.cv = n.cv, \n                     seed = base.seed)\n\ncvmoddwols <- cvvalue(data = df, xvar = covars,\n                      method = \"dWOLS\", n.fold = n.fold, n.cv = n.cv, \n                      seed = base.seed)\n\ncvmodpois <- cvvalue(data = df, xvar = covars,\n                     method = \"poisson\", n.fold = n.fold, n.cv = n.cv, \n                     seed = base.seed)\n\ncvmodlist2 <- cvvalue(data = df, xvar = covars,\n                      method = \"listDTR2\", n.fold = n.fold, n.cv = n.cv, \n                      seed = base.seed) # very slow\n\ncvmodcontrastreg <- cvvalue(data = df, xvar = covars,\n                            method = \"contrastReg\", n.fold = n.fold, \n                            n.cv = n.cv, \n                            seed = base.seed) # very slow\n```\n:::\n\n::: {.cell hash='chapter_18_cache/html/load_134e19846cd431bcb7bd127aeb284f21'}\n\n:::\n\n\nAs a next step, we need to combine all estimated ITRs and value functions:\n\n\n::: {.cell hash='chapter_18_cache/html/combine_99bbe1bd5b96768a0f7b1c88bb4e86ee'}\n\n```{.r .cell-code}\n# Combine CV results\n# Read in each CV result in a loop\nvhats.dhat <- dhats <- NULL\nmod_names <- c(\"cvmodall1\", \"cvmodall0\", \"cvmoddwols\", \"cvmodpois\", \"cvmodcontrastreg\", \"cvmodlist2\")\nfor (mod in mod_names){\n  thismod <- get(mod)\n  for (name in names(thismod)) {\n    # Get estimated values, vhat.dhat\n    vhats.dhat <- rbind(vhats.dhat,\n                        thismod[[name]] %>%\n                          map_df(~bind_rows(names(.x) %>% str_detect(\"vhat.dhat\") %>% keep(.x, .)), .id = \"fold\") %>%\n                          mutate(method = mod, cv.i = name))\n    # Get estimated rule from CV test fold, dhat\n    dhats  <- rbind(dhats,\n                    thismod[[name]] %>%\n                      map_df(~bind_rows(names(.x) %>% str_detect(\"^dhat$\") %>% keep(.x, .)), .id = \"fold\") %>%\n                      mutate(method = mod, cv.i = name))\n\n  }\n}\n\n# One time run to get true optimal and worst value\n# Simulated data only\ntrueV <- getTrueOptimalValue(n = big.n, seed = base.seed)\ntrueWorstV <- getTrueWorstValue(n = big.n, seed = base.seed)\n\n# Preprocess\nvhats.dhat %<>%\n  mutate(V = U/W,\n         VR = (U/W - trueWorstV) / (trueV - trueWorstV)) %>%\n  group_by(method) %>%\n  summarize(n.batches = n(),\n            n.nonnaU = sum(!is.na(U)),\n            n.nonnaW = sum(!is.na(W)),\n            meanV = mean(V, na.rm = T),\n            sdV = sd(V, na.rm = T),\n            meanVR = mean(VR, na.rm = T),\n            sdVR = sd(VR, na.rm = T),\n            .groups = \"keep\") %>%\n  ungroup %>%\n  arrange(desc(meanV)) %>%\n  mutate(method = case_when(\n    method == \"cvmodcontrastreg\" ~ \"Contrast\\n Regression\",\n    method == \"cvmodall0\" ~ \"All 0\",\n    method == \"cvmodall1\" ~ \"All 1\",\n    method == \"cvmodlist2\" ~ \"List DTR\\n (2 branches)\",\n    method == \"cvmoddwols\" ~ \"dWOLS\",\n    method == \"cvmodpois\" ~ \"Poisson\"),\n    method = factor(method,\n                    levels = method.vec,\n                    labels = method.vec)\n  )\n\ndhats %<>%\n  mutate(method = case_when(\n    method == \"cvmodcontrastreg\" ~ \"Contrast\\n Regression\",\n    method == \"cvmodall0\" ~ \"All 0\",\n    method == \"cvmodall1\" ~ \"All 1\",\n    method == \"cvmodlist2\" ~ \"List DTR\\n (2 branches)\",\n    method == \"cvmoddwols\" ~ \"dWOLS\",\n    method == \"cvmodpois\" ~ \"Poisson\"),\n    method = factor(method,\n                    levels = method.vec,\n                    labels = method.vec)\n  )\n```\n:::\n\n\n## Visualization of individualized treatment rules\n\n### Direct visualization\n#### listDTR\nIf the PM method already has built-in visualization (especially for tree-based methods), we can visualize the ITR directly. For example, we can simply use the function `plot()` to visualize the estimated ITR with the listDTR method.\n\n::: {.cell hash='chapter_18_cache/html/itr.list_75b69151b41124fbbe80a3823492548c'}\n\n```{.r .cell-code}\n#modlist3 %>% plot()\n```\n:::\n\n\nWe can also create our own visualization like Figure 1A in the chapter.\n\n::: {.cell hash='chapter_18_cache/html/itr.list.scatter_5d8055d60e2ff91743e046bd4c7793f6'}\n\n```{.r .cell-code}\ndf.list3 <- df %>%\n  mutate(d.list = ifelse(age.z > 0.599 | prevtrtB > 0.5, \"Recommend 1\", \"Recommend 0\"), # based on modlist3\n         Rule = factor(as.character(d.list), levels = c(\"Recommend 0\", \"Recommend 1\")),\n         prevtrtB = ifelse(prevtrtB == 1, \"Previous treatment is drug B\", \"Previous treatment is not drug B\")\n  )\n\n## Figure 1A\ndf.list3 %>%\n  ggplot(aes(x = age.z, fill = Rule))+\n  geom_histogram(position = position_dodge2(preserve = 'single'), binwidth = 0.1)+\n  facet_wrap(~ prevtrtB, nrow = 2) +\n  scale_fill_brewer(palette = \"Set1\") +\n  labs(x = \"Standardized age\", y = \"Count\") +\n  theme_classic() +\n  theme(legend.position = 'top', text = element_text(size = 20))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/itr.list.scatter-1.png){width=672}\n:::\n:::\n\n\nThe subgroup-level annualized relapse rate (ARR) can be calculated based on the listDTR ITR:\n\n::: {.cell hash='chapter_18_cache/html/itr.list.arr_b0bc9ca0f2d3cdadc26122c3f2a567c0'}\n\n```{.r .cell-code}\ndf.list3 %>%\n  group_by(trt, d.list) %>%\n  summarise(ARR = round(sum(y) / sum(years), 2),\n            n = n(),\n            `prop%` = round(n / nrow(df), 2)*100, .groups = \"drop\") %>%\n  rename(\"listDTR ITR\" = d.list,\n         \"Observed treatment\" = trt) %>%\n  kable() %>%\n  kable_styling(full_width = F)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Observed treatment </th>\n   <th style=\"text-align:left;\"> listDTR ITR </th>\n   <th style=\"text-align:right;\"> ARR </th>\n   <th style=\"text-align:right;\"> n </th>\n   <th style=\"text-align:right;\"> prop% </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> drug0 </td>\n   <td style=\"text-align:left;\"> Recommend 0 </td>\n   <td style=\"text-align:right;\"> 0.32 </td>\n   <td style=\"text-align:right;\"> 197 </td>\n   <td style=\"text-align:right;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> drug0 </td>\n   <td style=\"text-align:left;\"> Recommend 1 </td>\n   <td style=\"text-align:right;\"> 0.31 </td>\n   <td style=\"text-align:right;\"> 309 </td>\n   <td style=\"text-align:right;\"> 15 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> drug1 </td>\n   <td style=\"text-align:left;\"> Recommend 0 </td>\n   <td style=\"text-align:right;\"> 0.39 </td>\n   <td style=\"text-align:right;\"> 615 </td>\n   <td style=\"text-align:right;\"> 31 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> drug1 </td>\n   <td style=\"text-align:left;\"> Recommend 1 </td>\n   <td style=\"text-align:right;\"> 0.16 </td>\n   <td style=\"text-align:right;\"> 879 </td>\n   <td style=\"text-align:right;\"> 44 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\nPatients who received drug 0 and were recommended drug 0 by listDTR had a similar ARR on average than those who received drug 0 but were recommended drug 1 (0.32 vs 0.31). Patients who received drug 1 and were recommended drug 1 by listDTR had a much lower ARR on average than those who received drug 1 but were recommended drug 0 (0.16 vs 0.39). \n\n#### Score-based method\nAlthough some PM methods do not have built-in visualization or not as \"white-box\" as some more interpretable methods, there still might be ways to visualize the ITR. For example, score-based methods (such as Poisson and contrast regression) produce an estimate of the CATE score for each patient, and a classification tree can be fitted on these scores and visualized. Below is a histogram-density plot of the CATE scores estimated from the Poisson regression and the fitted classification tree using the estimated CATE scores. We pruned the tree so it only had three nodes for simplicity. The `rpart.plot` package has a built-in visualization function of the `rpart` model, `rpart.plot()`, which is how Figure 1B in the chapter was generated.\n\n::: {.cell result='asit' hash='chapter_18_cache/html/itr.tree_85b60448da19d14795aa4789b7001083'}\n\n```{.r .cell-code}\ndf[\"score.poisson\"] <- modpm$score.poisson\n\nggplot(df, aes(x = score.poisson)) + \n  geom_histogram(aes(y = ..density..), colour = \"black\", fill = \"lightblue\") +\n  geom_density(alpha = .2, fill = \"white\") +\n  labs(x = \"Estimated CATE score from the Poisson regression\", y = \"Density\") + \n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/itr.tree-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmodtree <- rpart(as.formula(paste0(\"score.poisson ~\", paste0(covars, collapse = \"+\"))),\n                 method = \"anova\", data = df, control = rpart.control(minsplit = 100, cp = 0.01)) # Fit Poisson CATE scores on a classification tree\n\nmodtree.pr <- prune(modtree, cp = 0.09) # I ended up choosing a higher cp value to have only 3 subgroups\n\n# print(rpart.rules(modtree.pr, cover = TRUE))\n\n## Figure 1B\nrpart.plot(modtree.pr, box.palette = \"RdBu\", type = 5, under = TRUE, tweak = 1.2, compress = TRUE)\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/itr.tree-2.png){width=672}\n:::\n:::\n\n\nThe CATE scores are now simplified as a tree classifier. Previous treatment of drug B and age seemed to be important in determining the CATE score values, which also showed up in the estimated from the listDTR method. Patients with previous treatment of drug B had the lowest CATE score on average (-0.76) and took up 41% of the samples (dark orange). Patients whose previous treatment was not drug B and age was >= -0.22 standard deviation of the mean also had a negative CATE score on average (-0.23) and took up 36% of the samples (light orange), but not as low as the dark orange group. Negative CATE scores mean that the number of relapses was expected to be lower for those recommended drug 1 than those recommended drug 0, so drug 1 was favored for them. For the blue group, the average CATE score was 0.13, taking up 23% of the samples, and they were expected to benefit from drug 0 based on the Poisson CATE scores. \n\n\n### ITR accuracy\n\nThe accuracy of ITR is the proportion of patients whose estimated ITR is the same as the true optimal ITR. The estimated ITRs have been obtained from the PM methods but we need to calculate the true optimal ITR. This is only possible for simulated data where the decision boundary is known. Based on the data generating mechanism in `simcountdata()`, `Iscore` is a score generated from a linear combination of baseline covariates where lower scores represented that drug 1 was better and higher scores represented that drug 0 was better. We then classified patients in 5 equal-size subgroups based on the `Iscore`, where groups 1 and 2 have drug 1 as their true optimal ITR and groups 3 and 4 have drug 0 as their true optimal ITR. Group 3 is considered the neutral group, where patients are indifferent to either drug so we assign the true optimal ITR to be their observed treatment. Thus, we identify the true optimal ITR for every patient based on this subgrouping, which was derived from their true score `Iscore`. Since we used cross validation in estimating the ITR, we need to apply the exact same cross validation to the true optimal ITR. This is achieved by specifying the same randomization seed in the cross validation loop (see `seed`). \n\n::: {.cell hash='chapter_18_cache/html/optd_3794bda5aa62711d2166be3ce414fca3'}\n\n```{.r .cell-code}\n## Create new columns\ndhats$d <- rep(NA, nrow(dhats)) # true d\n\n# Identify the true optimal treatment\n# See simcountdata() in the function script to learn more about Iscore\nsim <- df %>%\n  mutate(trueT = ifelse(as.numeric(Iscore) < 3, 1, 0),\n         trueT = ifelse(Iscore == 3, drug1, trueT)) # neutral group\n\n# Format data\ninput <- data.frame(y = sim$y, trt = sim$drug1, time = log(sim$years), sim[covars])\n\n# Cross validation loop\nfor(i in unique(dhats$cv.i)) {\n  seed <- base.seed*100 + as.numeric(str_extract(i, \"[0-9]+\"))\n  set.seed(seed)\n\n  # Create CV folds\n  folds <- createFolds(input$trt, k = n.fold, list = TRUE) # Stratified CV, follow the same as the simmain.R where folds were created on input$trt instead of sim$trt\n\n  for (fold.i in 1:n.fold){\n    testdata <- sim[folds[[fold.i]],]\n    # number of methods which succeeded for the given fold/batch. The \"is.na(dhat) == FALSE\" is to remove methods that didn't produce results for that fold/batch\n    nr <- nrow(dhats %>% filter(fold == paste0(\"fold\", fold.i), cv.i == i, is.na(dhat) == FALSE))\n    dhats$d[which(dhats$fold == paste0(\"fold\", fold.i) & dhats$cv.i == i & is.na(dhats$dhat) == FALSE)] <- rep(testdata$trueT, nr/nrow(testdata))\n    stopifnot(nr %% nrow(testdata) == 0)\n  }\n} # end of all cv iterations\n```\n:::\n\n\nOnce we identified the true optimal ITR ($d^{opt}$), we can calculate the accuracy in each validation fold for each PM method ($\\hat{d}_{pm}$). Mathematically, accuracy can be expressed as\n$$Accuracy_{pm}(\\boldsymbol{x}^{val}) = \\frac{1}{n^{val}}\\sum_{i = 1}^{n^{val}} I\\big(\\hat{d}_{pm}(\\boldsymbol{x}_i^{val}) == d^{opt}(\\boldsymbol{x}_i^{val})\\big),$$\nwhere $n^{val}$ is the sample size in the validation fold, $\\boldsymbol{x}_i^{val}$ is the baseline characteristics of the $i$th patient in the validation fold, and $pm$ stands for one PM method. \n\nBelow is how Figure 2 in the chapter was generated. It summarized the accuracy across all validation folds as a box plot so we can also learn the variability of accuracy across folds.\n\n::: {.cell hash='chapter_18_cache/html/accuracy_be89f7d0eea06b71892fa3b4f20726a7'}\n\n```{.r .cell-code}\n##### Accuracy #####\n## Calculate % accuracy for each iteration & summary statistics\ndhats.accuracy <- dhats %>%\n  group_by(method, cv.i, fold) %>%\n  summarise(accuracy = sum(dhat == d)/n(), .groups = \"drop\") %>%\n  ungroup\n\n## Make the accuracy plot, Figure 2\ndhats.accuracy %>%\n  ggplot(aes(x = method, y = accuracy)) +\n  geom_boxplot() +\n  geom_hline(yintercept = 1, linetype = 2, linewidth = 1, color = \"gray\") +\n  geom_hline(yintercept = 0.5, linetype = 2, linewidth = 1, color = \"gray\") +\n  theme_classic() +\n  labs(x = \"Method\", y = \"Accuracy\") +\n  theme(axis.text = element_text(size = 15),\n        axis.title.y = element_text(size = 15),\n        axis.title.x = element_text(size = 15),\n        axis.text.x = element_text(angle = 0, size = 15),\n        strip.text.x = element_text(size = 15))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/accuracy-1.png){width=672}\n:::\n:::\n\n\n### ITR agreement\nWhen we do not know the true data generating mechanism, e.g., real-world data, we cannot compare the estimated ITR with the true optimal ITR. However, we can compare the estimated ITR with another estimated ITR, and this is called agreement. Agreement is the proportion of patients whose estimated ITR of a method is the same as the estimated ITR of another method. Thus, agreement is between two methods. Mathematically,\n$$Agreement_{1, 2}(\\boldsymbol{x}^{val}) = \\frac{1}{n^{val}} \\sum_{i = 1}^{n^{val}} I\\big( \\hat{d}_{1}(\\boldsymbol{x}^{val}) == \\hat{d}_{2} (\\boldsymbol{x}^{val}) \\big), $$\nwhere $n^{val}$ is the sample size in the validation fold, $\\boldsymbol{x}_i^{val}$ is the baseline characteristics of the $i$th patient in the validation fold, and $1, 2$ stands for method 1 and method 2. \n\n\n::: {.cell hash='chapter_18_cache/html/agreement_23ebc4993db779364a63881dea6102fd'}\n\n```{.r .cell-code}\n##### Agreement #####\ndhats.concat <- dhats %>%\n  arrange(cv.i, fold, method) %>%\n  mutate(iteration.fold = (as.numeric(str_extract(cv.i, \"[0-9]+\")) - 1) * 10 + as.numeric(str_extract(fold, \"[0-9]+\"))) %>% \n  dplyr::select(method, iteration.fold, dhat) %>%\n  group_by(method, iteration.fold) %>%\n  mutate(i = 1:n()) %>%  \n  ungroup\n\nm <- length(method.vec)\ndhats.agreement <- matrix(nrow = m, ncol = m)\ncolnames(dhats.agreement) <- method.vec\nrownames(dhats.agreement) <- method.vec\n\nfor(k in seq_len(m)){\n  for(j in seq(k, m)){\n    data.k <- dhats.concat %>% filter(method == method.vec[k])\n    data.j <- dhats.concat %>% filter(method == method.vec[j])\n    data.jk <- data.k %>% full_join(data.j, by = c(\"iteration.fold\", \"i\"))\n    dhats.agreement[k, j] <- dhats.agreement[j, k] <- sum(data.jk$dhat.x == data.jk$dhat.y, na.rm = T) / sum(is.na(data.jk$dhat.x) == FALSE & is.na(data.jk$dhat.y) == FALSE)\n  }\n}\n\n# Make the agreement plot, Figure 3\ncorrplot(dhats.agreement, method = \"color\",  type = \"lower\",\n         addCoef.col = \"orange\", number.cex = 1.5,\n         tl.cex = 1.2, cl.cex = 1.2, tl.col = \"black\", tl.srt = 0, tl.offset = 1.5)\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/agreement-1.png){width=768}\n:::\n:::\n\n\nWe used the  `corrplot` package to generate Figure 3 in the chapter but agreement can be visualized in other creative ways that you prefer.\n\n## Patient well-being\nPatient well-being is evaluated via the value function, which is defined as the expected outcome had they followed the specified ITR. Like a fortune teller's crystal ball, this metric tells us how well the patients would do on average under each ITR. We can then compare across different ITRs and identify an optimal ITR. Cross validation is necessary here to mitigate over-fitting, and we visualized the value function results as error bar plots. The mean and standard deviation of the value functions have been preprocessed previously. We use `ggplot()` to generate the error bar plots. Figure 4A is the original value function estimates, and Figure 4B is the standardized value ratio estimates, which convert value functions to a ratio where 1 is always more desirable.\n\n::: {.cell hash='chapter_18_cache/html/value_597edff1c92c0ad039c56f7a8c3135bc'}\n\n```{.r .cell-code}\n##### Errorbar plot #####\n# Figure 4A\np4a <- vhats.dhat %>%\n  ggplot(aes(x = method, y = meanV)) +\n  geom_point(size = 8, shape = 16, color = \"navy\") +\n  geom_errorbar(aes(ymin = meanV - sdV, ymax = meanV + sdV), width = 0.3, size = 2, position = position_dodge(0.9), color = \"navy\") +\n  theme_classic() + xlab(\"\") + ylab(\"Cross-validated value (mean +- SD)\") +\n  theme(axis.text = element_text(size = 15), axis.title.y = element_text(size = 15)) +\n  geom_hline(yintercept = vhats.dhat$meanV[which(vhats.dhat$method == \"All 1\")], linetype = 2, size = 1.5, color = \"gray\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n```{.r .cell-code}\n##### Value ratio #####\n# Figure 4B\np4b <- vhats.dhat %>%\n  dplyr::select(method, contains(\"VR\"), n.nonnaU) %>%\n  ggplot(aes(x = method, y = meanVR)) +\n  geom_point(size = 8, color = \"navy\") +\n  geom_errorbar(aes(ymin = meanVR - sdVR, ymax = meanVR + sdVR), width = 0.3, size = 2, position = position_dodge(0.9), color = \"navy\") +\n  geom_hline(yintercept = 1, color = \"gray\", linetype = 2, size = 1) +\n  geom_hline(yintercept = 0, color = \"gray\", linetype = 2, size = 1) +\n  scale_y_continuous(breaks = seq(0, 1, length = 6)) +\n  theme_classic() +\n  labs(x = \"\", y = \"Value ratio of cross-validated estimated decision rule (mean +- SD)\") +\n  theme(axis.text = element_text(size = 13),\n        axis.title.y = element_text(size = 15),\n        axis.title.x = element_text(size = 15),\n        axis.text.x = element_text(size = 15),\n        strip.text.x = element_text(size = 12))\n\n# Figure 4\nggarrange(p4a, p4b, ncol = 2, nrow = 1, labels = c(\"A\", \"B\"))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/value-1.png){width=1440}\n:::\n:::\n\n\n## Responder diagnostics\n### Validation\nThe package we used for the two score-based methods (Poisson and contrast regression), `PrecMed`, has built-in visualization tools to diagnose the results: validation box plots `boxplot()`,  validation curves `plot()`, and area between curves (ABC) statistics `abc()`.\n\n\n::: {.cell hash='chapter_18_cache/html/validation_983585375dbfe0e86d9a4479c1c8343a'}\n\n```{.r .cell-code}\n##### Validation of ITR scores #####\n# Figure 5A\np5a <- boxplot(modcv, ylab = \"Rate ratio between T=1 and T=0 in each subgroup\")\n# Figure 5B\np5b <- plot(modcv, ylab = \"Rate ratio between T=1 and T=0 in each subgroup\")\n\n# Figure 5\nggarrange(p5a, p5b, ncol = 1, nrow = 2, labels = c(\"A\", \"B\"))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/validation-1.png){width=768}\n:::\n:::\n\n\nThe `PrecMed` package has more PM methods implemented other than Poisson and contrast regression that you can try, such as negative binomial and two regressions. See its documentation for more details.\n\n### Univariate comparision of patient characteristics\nThe 60/40 cutoff was used in the chapter to split patients into \"high responders\" and \"standard responders\". The function `CreateTableOne()` in the `tableone` package was used to generate a table comparing side-by-side the baseline characteristics between the two responder groups. \n\n::: {.cell hash='chapter_18_cache/html/unicomp.table_95c750e1ff9e7f5f597b17020c984ccf'}\n\n```{.r .cell-code}\n##### Side-by-side baseline characteristic comparison between responder subgroups #####\ncutoff <- quantile(modpm$score.poisson, 0.6) # 60/40 high vs standard responder split\ndf[\"responder to T=1\"] <- ifelse(modpm$score.poisson < cutoff, \"High\", \"Standard\")\ndf[\"age.z\"] <- as.numeric(df$age.z)\ndf[\"previous_cost.z\"] <- as.numeric(df$previous_cost.z)\n\nlabs <- list(\"age.z\" = \"Standardized baseline age\", \"female\" = \"Female\",\n             \"prevtrtB\" = \"Previous treatment drug B\", \"prevtrtC\" = \"Previous treatment drug C\",\n             \"prevnumsymp1\" = \"Previous number of symptoms == 1\",\n             \"prevnumsymp2p\" = \"Previuos number of symptoms >= 2\",\n             \"previous_cost.z\" = \"Standardized previous medical cost\\n(excluding medication)\",\n             \"previos_number_relapses\" = \"Previous number of relapses\")\n\ntab <- CreateTableOne(vars = covars, strata = \"responder to T=1\", data = df, test = F) %>% print(smd = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                      Stratified by responder to T=1\n                                       High         Standard     SMD   \n  n                                     1200          800              \n  age.z (mean (SD))                     0.29 (0.94) -0.44 (0.92)  0.789\n  female (mean (SD))                    0.69 (0.46)  0.84 (0.36)  0.384\n  prevtrtB (mean (SD))                  0.67 (0.47)  0.02 (0.15)  1.867\n  prevtrtC (mean (SD))                  0.02 (0.13)  0.26 (0.44)  0.750\n  prevnumsymp1 (mean (SD))              0.33 (0.47)  0.15 (0.35)  0.431\n  prevnumsymp2p (mean (SD))             0.05 (0.22)  0.11 (0.31)  0.208\n  previous_cost.z (mean (SD))          -0.08 (1.00)  0.12 (0.99)  0.203\n  previous_number_relapses (mean (SD))  0.41 (0.64)  0.47 (0.68)  0.104\n```\n:::\n:::\n\n\nWe can directly present the table or visualize the comparison with errorbar plots, which is what the chapter presented (Figure 6A). Here we show both. Tables are helpful if specific numbers are important but readers would have to perform mental comparison to understand which value is higher, whereas plots are helpful if you want people to quickly identify the larger differences and not focus on the specific values of certain results.\n\n\n::: {.cell hash='chapter_18_cache/html/unicomp.visual_73ac1c924bdcc82469760c3aa322c4c9'}\n\n```{.r .cell-code}\nsmd <- as_tibble(tab, rownames = \"var\") %>%\n  rowwise() %>%\n  mutate(variable = as.factor(str_extract(var, \".*(?= \\\\(mean \\\\(SD\\\\)\\\\))\"))) %>%\n  filter(!is.na(variable)) %>%\n  arrange(desc(SMD)) %>%\n  mutate(smd = paste0(\"SMD =\", SMD),\n         variable = labs[[variable]]) %>%\n  dplyr::select(variable, smd) %>%\n  mutate(ID = 1)\n\nlevels <- unique(smd$variable)\n\np6a <- df %>%\n  mutate(ID = 1:n()) %>%\n  dplyr::select(all_of(covars), ID, contains(\"responder\")) %>%\n  melt(id = c(\"ID\", \"responder to T=1\")) %>%\n  rowwise() %>%\n  mutate(variable = labs[[variable]]) %>%\n  left_join(smd, by = c(\"variable\", \"ID\")) %>%\n  mutate(variable2 = factor(variable, levels = levels)) %>%\n  ggplot(aes(x = reorder(variable2, desc(variable2)), color = `responder to T=1`, y = value, group = `responder to T=1`)) +\n  stat_summary(fun = mean, geom = \"point\", size = 4, position = position_dodge(width = 0.5)) +\n  stat_summary(fun.data = mean_sdl, geom = \"errorbar\", position = position_dodge(width = 0.5), width= 0.3, size = 1.2) +\n  geom_hline(yintercept = 0, color = \"gray\", linetype = \"dashed\") +\n  geom_text(aes(label = smd), hjust = -0.5, y = -1.5, color = \"darkgray\", size = 3.5) +\n  # facet_wrap(~ variable2, nrow = 4) +\n  labs(x = \"Baseline patient characteristic\",\n       y = \"Mean +- SD\") +\n  coord_flip() +\n  scale_color_brewer(palette = \"Set2\")  +\n  theme_classic() +\n  theme(legend.position = \"top\",\n        axis.text = element_text(size = 13),\n        axis.title.y = element_text(size = 15),\n        axis.title.x = element_text(size = 15),\n        axis.text.x = element_text(size = 15),\n        strip.text.x = element_text(size = 12))\n\n# Figure 6A\nggarrange(p6a, nrow = 1, labels = c(\"A\"))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/unicomp.visual-1.png){width=960}\n:::\n:::\n\n\nWe can also show the density of ITR scores obtained from the score-based methods. The results can be found in `modpm` and we used histogram to visualize (Figure 6B).\n\n::: {.cell hash='chapter_18_cache/html/density_67fdfea53425766dc76ef755a0beb029'}\n\n```{.r .cell-code}\n##### Density of ITR score #####\ndataplot <- data.frame(score = factor(rep(c(\"Naive Poisson\", \"Contrast Regression\"),\n                                          each = length(modpm$score.poisson))),\n                       value = c(modpm$score.poisson, modpm$score.contrastReg))\n\np6b <- dataplot %>%\n  ggplot(aes(x = value, fill = score)) +\n  geom_density(alpha = 0.5) +\n  scale_fill_manual(values = c(\"dodgerblue\", \"gray30\")) +\n  geom_vline(xintercept = 0, color = \"darkgray\", linetype = \"dashed\", size = 1) +\n  labs(x = \"Estimated CATE score\", y = \"Density\", fill = \"Method\") +\n  theme_classic() +\n  theme(legend.position = c(0.2, 0.8),\n        axis.text = element_text(size = 13),\n        axis.title.y = element_text(size = 15),\n        axis.title.x = element_text(size = 15),\n        axis.text.x = element_text(size = 15),\n        strip.text.x = element_text(size = 12))\n```\n:::\n\n\nThe ITR scores are essentially a linear combination of the baseline characteristics, thus it might be also of interest for one to know the corresponding coefficients (or weights) which shows how much each baseline variable contributed to the ITR score. To make it comparable across different scales of the baseline variables, we used the scaled data and the model result `modpm.s` was used to extract the coefficients and visualize as a bar plot. The coefficients can be presented in a table as well.\n\n\n::: {.cell hash='chapter_18_cache/html/coefs_f9bf5219f1e5ca248ac3f50753cb6875'}\n\n```{.r .cell-code}\n# Coefficients\ncoef <- modpm.s$coefficients\n\np6c <- coef %>%\n  as_tibble(rownames = \"varname\") %>%\n  melt(id.vars = \"varname\") %>%\n  filter(variable == \"poisson\", varname != \"(Intercept)\") %>%\n  mutate(absval = abs(value),\n         sign = ifelse(value > 0, \"+\", \"-\")) %>%\n  arrange(absval) %>%\n  mutate(varname = factor(varname, levels = unique(varname))) %>%\n  ggplot(aes(x = varname, y = absval, fill = sign)) +\n  geom_bar(stat = \"identity\", width = 0.5) +\n  scale_fill_brewer(palette = \"Set1\") +\n  scale_x_discrete(labels = labs) +\n  coord_flip() +\n  labs(y = \"Absolute value of the estimated coefficient of CATE scores\\nbased on Poisson regression\", x = \"Baseline patient characteristic\") +\n  theme_minimal() +\n  theme(legend.position = c(0.8, 0.2),\n        axis.text = element_text(size = 13),\n        axis.title.y = element_text(size = 15),\n        axis.title.x = element_text(size = 15),\n        axis.text.x = element_text(size = 15),\n        strip.text.x = element_text(size = 12))\n\n# Figure 6B, 6C\nggarrange(p6b, p6c, nrow = 2, labels = c(\"B\", \"C\"))\n```\n\n::: {.cell-output-display}\n![](chapter_18_files/figure-html/coefs-1.png){width=1152}\n:::\n\n```{.r .cell-code}\n# Coefficients presented as a table\ncoef %>% round(2) %>% kable() %>% kable_styling(full_width = F)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:right;\"> poisson </th>\n   <th style=\"text-align:right;\"> contrastReg </th>\n   <th style=\"text-align:right;\"> SE_contrastReg </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> (Intercept) </td>\n   <td style=\"text-align:right;\"> -0.30 </td>\n   <td style=\"text-align:right;\"> -0.25 </td>\n   <td style=\"text-align:right;\"> 0.46 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> age.z </td>\n   <td style=\"text-align:right;\"> -0.21 </td>\n   <td style=\"text-align:right;\"> -0.23 </td>\n   <td style=\"text-align:right;\"> 0.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> female </td>\n   <td style=\"text-align:right;\"> 0.20 </td>\n   <td style=\"text-align:right;\"> 0.29 </td>\n   <td style=\"text-align:right;\"> 0.43 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> prevtrtB </td>\n   <td style=\"text-align:right;\"> -0.63 </td>\n   <td style=\"text-align:right;\"> -0.86 </td>\n   <td style=\"text-align:right;\"> 0.36 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> prevtrtC </td>\n   <td style=\"text-align:right;\"> 0.19 </td>\n   <td style=\"text-align:right;\"> 0.21 </td>\n   <td style=\"text-align:right;\"> 0.54 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> prevnumsymp1 </td>\n   <td style=\"text-align:right;\"> -0.14 </td>\n   <td style=\"text-align:right;\"> -0.42 </td>\n   <td style=\"text-align:right;\"> 0.39 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> prevnumsymp2p </td>\n   <td style=\"text-align:right;\"> 0.20 </td>\n   <td style=\"text-align:right;\"> 1.05 </td>\n   <td style=\"text-align:right;\"> 0.58 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> previous_cost.z </td>\n   <td style=\"text-align:right;\"> 0.06 </td>\n   <td style=\"text-align:right;\"> 0.13 </td>\n   <td style=\"text-align:right;\"> 0.18 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> previous_number_relapses </td>\n   <td style=\"text-align:right;\"> 0.08 </td>\n   <td style=\"text-align:right;\"> 0.26 </td>\n   <td style=\"text-align:right;\"> 0.23 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Version info {.unnumbered}\nThis chapter was rendered using the following version of R and its packages:\n\n\n::: {.cell hash='chapter_18_cache/html/unnamed-chunk-4_535ed23ccadd36f77cd0261d64fdb0ec'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.4\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Zurich\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] table1_1.4.3      fastDummies_1.6.3 reshape2_1.4.4    truncnorm_1.0-9  \n [5] kableExtra_1.3.4  knitr_1.42        ggpubr_0.6.0      MASS_7.3-58.4    \n [9] corrplot_0.92     caret_6.0-94      lattice_0.21-8    gbm_2.1.8.1      \n[13] tableone_0.13.2   qwraps2_0.5.2     rpart.plot_3.1.1  rpart_4.1.19     \n[17] precmed_1.0.0     DTRreg_1.7        magrittr_2.0.3    lubridate_1.9.2  \n[21] forcats_1.0.0     stringr_1.5.0     dplyr_1.1.2       purrr_1.0.1      \n[25] readr_2.1.4       tidyr_1.3.0       tibble_3.2.1      ggplot2_3.4.2    \n[29] tidyverse_2.0.0  \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3    geeM_0.10.1           rstudioapi_0.14      \n  [4] jsonlite_1.8.4        shape_1.4.6           MESS_0.5.9           \n  [7] ggstance_0.3.6        farver_2.1.1          rmarkdown_2.21       \n [10] geepack_1.3.9         vctrs_0.6.2           rstatix_0.7.2        \n [13] webshot_0.5.4         htmltools_0.5.5       haven_2.5.2          \n [16] survey_4.2-1          broom_1.0.4           Formula_1.2-5        \n [19] pROC_1.18.2           parallelly_1.36.0     htmlwidgets_1.6.2    \n [22] plyr_1.8.8            gam_1.22-2            lifecycle_1.0.3      \n [25] iterators_1.0.14      pkgconfig_2.0.3       Matrix_1.5-4         \n [28] R6_2.5.1              fastmap_1.1.1         future_1.32.0        \n [31] digest_0.6.31         colorspace_2.1-0      fansi_1.0.4          \n [34] timechange_0.2.0      httr_1.4.6            polyclip_1.10-4      \n [37] abind_1.4-5           compiler_4.3.0        withr_2.5.0          \n [40] backports_1.4.1       carData_3.0-5         DBI_1.1.3            \n [43] ggforce_0.4.1         ggsignif_0.6.4        lava_1.7.2.1         \n [46] ModelMetrics_1.2.2.2  tools_4.3.0           future.apply_1.11.0  \n [49] nnet_7.3-18           glue_1.6.2            DiagrammeR_1.0.10    \n [52] nlme_3.1-162          grid_4.3.0            ggformula_0.10.4     \n [55] generics_0.1.3        recipes_1.0.6         gtable_0.3.3         \n [58] labelled_2.11.0       tzdb_0.4.0            class_7.3-21         \n [61] data.table_1.14.8     hms_1.1.3             xml2_1.3.4           \n [64] car_3.1-2             utf8_1.2.3            foreach_1.5.2        \n [67] pillar_1.9.0          mitools_2.4           splines_4.3.0        \n [70] tweenr_2.0.2          survival_3.5-5        tidyselect_1.2.0     \n [73] svglite_2.1.1         stats4_4.3.0          xfun_0.39            \n [76] hardhat_1.3.0         mosaicCore_0.9.2.1    timeDate_4022.108    \n [79] visNetwork_2.1.2      stringi_1.7.12        yaml_2.3.7           \n [82] evaluate_0.21         codetools_0.2-19      data.tree_1.0.0      \n [85] cli_3.6.1             randomForestSRC_3.2.2 systemfonts_1.0.4    \n [88] munsell_0.5.0         Rcpp_1.0.10           globals_0.16.2       \n [91] parallel_4.3.0        gower_1.0.1           listenv_0.9.0        \n [94] glmnet_4.1-7          viridisLite_0.4.2     ipred_0.9-14         \n [97] scales_1.2.1          prodlim_2023.03.31    ggridges_0.5.4       \n[100] rlang_1.1.1           rvest_1.0.3          \n```\n:::\n:::\n\n\n## References {.unnumbered}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/table1-1.0/table1_defaults.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}